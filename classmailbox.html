<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RCI Memory Lender: mailbox&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RCI Memory Lender
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmailbox-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mailbox&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>map-based lender  
 <a href="classmailbox.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lender_8hpp_source.html">lender.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a54959b06924992b0051396049a59e6b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmailbox.html#a54959b06924992b0051396049a59e6b8">mailbox</a> (const std::vector&lt; size_t &gt; s, int max, int reads=1)</td></tr>
<tr class="memdesc:a54959b06924992b0051396049a59e6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct mailbox class  <a href="classmailbox.html#a54959b06924992b0051396049a59e6b8">More...</a><br /></td></tr>
<tr class="separator:a54959b06924992b0051396049a59e6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1e09753e084c9fbb695830df3706c4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmailbox.html#a7b1e09753e084c9fbb695830df3706c4">fill</a> () -&gt; <a class="el" href="classbuffer__ptr.html">buffer_ptr</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a7b1e09753e084c9fbb695830df3706c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get shared pointer to empty/free buffer  <a href="classmailbox.html#a7b1e09753e084c9fbb695830df3706c4">More...</a><br /></td></tr>
<tr class="separator:a7b1e09753e084c9fbb695830df3706c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79a794d725e6bd77f9942e11ac9edce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmailbox.html#ae79a794d725e6bd77f9942e11ac9edce">queue</a> (int key, <a class="el" href="classbuffer__ptr.html">buffer_ptr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:ae79a794d725e6bd77f9942e11ac9edce"><td class="mdescLeft">&#160;</td><td class="mdescRight">give shared pointer back to queue for another thread  <a href="classmailbox.html#ae79a794d725e6bd77f9942e11ac9edce">More...</a><br /></td></tr>
<tr class="separator:ae79a794d725e6bd77f9942e11ac9edce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20b1e009b51392d111d84fb3ff5c105"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmailbox.html#ab20b1e009b51392d111d84fb3ff5c105">operate</a> (int key) -&gt; <a class="el" href="classbuffer__ptr.html">buffer_ptr</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ab20b1e009b51392d111d84fb3ff5c105"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a shared pointer from the map to operate on  <a href="classmailbox.html#ab20b1e009b51392d111d84fb3ff5c105">More...</a><br /></td></tr>
<tr class="separator:ab20b1e009b51392d111d84fb3ff5c105"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2bf3815391f15d07bc620303d81584f8"><td class="memItemLeft" align="right" valign="top"><a id="a2bf3815391f15d07bc620303d81584f8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>mail_test</b></td></tr>
<tr class="separator:a2bf3815391f15d07bc620303d81584f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class mailbox&lt; T &gt;</h3>

<p>map-based lender </p>
<p>uses a map to store the buffer pointers for other threads. Uses keys so threads will take the specific data they need.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>primitive (including std::complex) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a54959b06924992b0051396049a59e6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54959b06924992b0051396049a59e6b8">&#9670;&nbsp;</a></span>mailbox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmailbox.html">mailbox</a>&lt; T &gt;::<a class="el" href="classmailbox.html">mailbox</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct mailbox class </p>
<p>Instantiator takes in type (from the template), the shape and the max number of buffers for this type, as with <a class="el" href="classrecycle__memory.html" title="base class for memory lenders that manage pointers">recycle_memory</a> and library. Additionally, it will take in the number of times a buffer can be delivered to another thread in the "mail".</p>
<p>DESIGN: Buffers are eagerly allocated in this function to reduce any latency that might appear later in the pipeline for allocation. Users can experiment with optimal # of buffers with variable 'max'</p>
<p>NOTE: map is dynamically sized, there is no limit to the number of keys it can contain (even though there is currently a limit to the number of buffers that the mailbox will keep track of).</p>
<p>TODO: there are cases where buffers may never get the last read needed to be destroyed OR where a buffer may never arrive for a key. (the second case is assumed to be less likely). In both these cases, garbage collection is needed to free threads/buffers. A possible solution for this is a "timeout" in the value. The value could be checked by a thread specific to this purpose, or whenever a new thread comes in. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7b1e09753e084c9fbb695830df3706c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1e09753e084c9fbb695830df3706c4">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classmailbox.html">mailbox</a>&lt; T &gt;::fill</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get shared pointer to empty/free buffer </p>
<p>data found in the pointer already is not usable - already been freed</p>
<p>NOTE: this is a blocking operation until a buffer is free used for writers </p>

</div>
</div>
<a id="ab20b1e009b51392d111d84fb3ff5c105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20b1e009b51392d111d84fb3ff5c105">&#9670;&nbsp;</a></span>operate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classmailbox.html">mailbox</a>&lt; T &gt;::operate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classbuffer__ptr.html">buffer_ptr</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a shared pointer from the map to operate on </p>
<p>this operation can create a key-value pair if none exist.</p>
<p>DESIGN: The value count will decrement at the beginning before waiting (if the buffer is not yet delivered). This removes the need to reaquire both locks if deletion is needed. Because the value is a shared_ptr, it will persist even if the key-value is deleted from the map.</p>
<p>NOTE: this is a blocking operation until a buffer is added to the key used for readers </p>

</div>
</div>
<a id="ae79a794d725e6bd77f9942e11ac9edce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79a794d725e6bd77f9942e11ac9edce">&#9670;&nbsp;</a></span>queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmailbox.html">mailbox</a>&lt; T &gt;::queue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbuffer__ptr.html">buffer_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>give shared pointer back to queue for another thread </p>
<p>this can be used to deliver a particular buffer (associated with a key) to another thread. this operation can create a key-value pair, and will also fill in an existing pair if it has already been made.</p>
<p>After queuing, the thread will notify all waiting threads.</p>
<p>In debugging mode, there are checks that keys are not used twice.</p>
<p>NOTE: this is a blocking operation </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="lender_8hpp_source.html">lender.hpp</a></li>
<li><a class="el" href="mailbox_8hpp_source.html">mailbox.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
