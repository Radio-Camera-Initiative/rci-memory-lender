<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RCI Memory Lender: recycle_memory&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RCI Memory Lender
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classrecycle__memory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">recycle_memory&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>base class for memory lenders that manage pointers  
 <a href="classrecycle__memory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lender_8hpp_source.html">lender.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5805700698114c984d659c8d4f4333e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrecycle__memory.html#a5805700698114c984d659c8d4f4333e2">return_memory</a> (T *p)</td></tr>
<tr class="memdesc:a5805700698114c984d659c8d4f4333e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to reclaim memory  <a href="classrecycle__memory.html#a5805700698114c984d659c8d4f4333e2">More...</a><br /></td></tr>
<tr class="separator:a5805700698114c984d659c8d4f4333e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affed8b414b24486ac7d3977cb726b5d0"><td class="memItemLeft" align="right" valign="top"><a id="affed8b414b24486ac7d3977cb726b5d0"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>free_condition</b> () -&gt; bool</td></tr>
<tr class="separator:affed8b414b24486ac7d3977cb726b5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf0c200176a67986c8ad6a4ce9de7fe"><td class="memItemLeft" align="right" valign="top"><a id="abdf0c200176a67986c8ad6a4ce9de7fe"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrecycle__memory.html#abdf0c200176a67986c8ad6a4ce9de7fe">private_free_size</a> () -&gt; int</td></tr>
<tr class="memdesc:abdf0c200176a67986c8ad6a4ce9de7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">testing function <br /></td></tr>
<tr class="separator:abdf0c200176a67986c8ad6a4ce9de7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562391e799aa05714da5760b3cf58558"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrecycle__memory.html#a562391e799aa05714da5760b3cf58558">recycle_memory</a> (const std::vector&lt; size_t &gt; s, unsigned int max)</td></tr>
<tr class="memdesc:a562391e799aa05714da5760b3cf58558"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct the base class (no functions to use pointers)  <a href="classrecycle__memory.html#a562391e799aa05714da5760b3cf58558">More...</a><br /></td></tr>
<tr class="separator:a562391e799aa05714da5760b3cf58558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6bc5e6b26c45519a77fe1ceb07a9d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrecycle__memory.html#acc6bc5e6b26c45519a77fe1ceb07a9d6">~recycle_memory</a> ()</td></tr>
<tr class="memdesc:acc6bc5e6b26c45519a77fe1ceb07a9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroy base class, delete raw pointers  <a href="classrecycle__memory.html#acc6bc5e6b26c45519a77fe1ceb07a9d6">More...</a><br /></td></tr>
<tr class="separator:acc6bc5e6b26c45519a77fe1ceb07a9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9312bd45680bd8fbfd766b5f271c081"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrecycle__memory.html#ae9312bd45680bd8fbfd766b5f271c081">shape</a> () const noexcept -&gt; const std::vector&lt; size_t &gt; &amp;</td></tr>
<tr class="memdesc:ae9312bd45680bd8fbfd766b5f271c081"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Idk what this is for lol.  <a href="classrecycle__memory.html#ae9312bd45680bd8fbfd766b5f271c081">More...</a><br /></td></tr>
<tr class="separator:ae9312bd45680bd8fbfd766b5f271c081"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2548d1c336820c69b6a2c1c91b041186"><td class="memItemLeft" align="right" valign="top"><a id="a2548d1c336820c69b6a2c1c91b041186"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrecycle__memory.html#a2548d1c336820c69b6a2c1c91b041186">size</a></td></tr>
<tr class="memdesc:a2548d1c336820c69b6a2c1c91b041186"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the data <br /></td></tr>
<tr class="separator:a2548d1c336820c69b6a2c1c91b041186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa2b75e3e3f3d623d778dc47b1e30e4"><td class="memItemLeft" align="right" valign="top"><a id="a9fa2b75e3e3f3d623d778dc47b1e30e4"></a>
std::deque&lt; T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrecycle__memory.html#a9fa2b75e3e3f3d623d778dc47b1e30e4">free_q</a></td></tr>
<tr class="memdesc:a9fa2b75e3e3f3d623d778dc47b1e30e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">queue of unused pointers for the <a class="el" href="classbuffer__ptr.html" title="smart wrapper for shared_ptr">buffer_ptr</a> <br /></td></tr>
<tr class="separator:a9fa2b75e3e3f3d623d778dc47b1e30e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043d28f603a7929c0323b6048c1ba269"><td class="memItemLeft" align="right" valign="top"><a id="a043d28f603a7929c0323b6048c1ba269"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrecycle__memory.html#a043d28f603a7929c0323b6048c1ba269">free_mutex</a></td></tr>
<tr class="memdesc:a043d28f603a7929c0323b6048c1ba269"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex of free pointer queue <br /></td></tr>
<tr class="separator:a043d28f603a7929c0323b6048c1ba269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4bfcb93fd1d1091ef20398e2b00194"><td class="memItemLeft" align="right" valign="top"><a id="aef4bfcb93fd1d1091ef20398e2b00194"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrecycle__memory.html#aef4bfcb93fd1d1091ef20398e2b00194">free_variable</a></td></tr>
<tr class="memdesc:aef4bfcb93fd1d1091ef20398e2b00194"><td class="mdescLeft">&#160;</td><td class="mdescRight">cv of free pointer queue <br /></td></tr>
<tr class="separator:aef4bfcb93fd1d1091ef20398e2b00194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0358163e193d7e197e56f0e85408c354"><td class="memItemLeft" align="right" valign="top"><a id="a0358163e193d7e197e56f0e85408c354"></a>
std::set&lt; T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrecycle__memory.html#a0358163e193d7e197e56f0e85408c354">pointers</a></td></tr>
<tr class="memdesc:a0358163e193d7e197e56f0e85408c354"><td class="mdescLeft">&#160;</td><td class="mdescRight">test that all pointers in its queues self-originate <br /></td></tr>
<tr class="separator:a0358163e193d7e197e56f0e85408c354"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aadb6a3adc370d447cda567452cc71cc8"><td class="memItemLeft" align="right" valign="top"><a id="aadb6a3adc370d447cda567452cc71cc8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_deleter</b></td></tr>
<tr class="separator:aadb6a3adc370d447cda567452cc71cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25b6aed09afc7d31285654406132007"><td class="memItemLeft" align="right" valign="top"><a id="aa25b6aed09afc7d31285654406132007"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_ptr&lt; T &gt;</b></td></tr>
<tr class="separator:aa25b6aed09afc7d31285654406132007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087fc7e99664a53350c1da55965acdd5"><td class="memItemLeft" align="right" valign="top"><a id="a087fc7e99664a53350c1da55965acdd5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>unit_test</b></td></tr>
<tr class="separator:a087fc7e99664a53350c1da55965acdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class recycle_memory&lt; T &gt;</h3>

<p>base class for memory lenders that manage pointers </p>
<p><a class="el" href="classrecycle__memory.html" title="base class for memory lenders that manage pointers">recycle_memory</a> class will both MAKE and DESTROY memory that is within the shared_ptr</p>
<p><a class="el" href="classrecycle__memory.html" title="base class for memory lenders that manage pointers">recycle_memory</a> needs to store unused memory for a particular type needs to store queues for threads to take from</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>primitive (including std::complex) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a562391e799aa05714da5760b3cf58558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562391e799aa05714da5760b3cf58558">&#9670;&nbsp;</a></span>recycle_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrecycle__memory.html">recycle_memory</a>&lt; T &gt;::<a class="el" href="classrecycle__memory.html">recycle_memory</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct the base class (no functions to use pointers) </p>
<p>Instantiator takes in only one type (from the template), the shape and the max number of buffers for this type. This means <a class="el" href="classrecycle__memory.html" title="base class for memory lenders that manage pointers">recycle_memory</a> will not exceed a certain memory size.</p>
<p>DESIGN: Memory is eagerly allocated in this function to reduce any latency that might appear later in the pipeline for allocation. Users can experiment with optimal # of buffers with variable 'max' </p>

</div>
</div>
<a id="acc6bc5e6b26c45519a77fe1ceb07a9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6bc5e6b26c45519a77fe1ceb07a9d6">&#9670;&nbsp;</a></span>~recycle_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrecycle__memory.html">recycle_memory</a>&lt; T &gt;::~<a class="el" href="classrecycle__memory.html">recycle_memory</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destroy base class, delete raw pointers </p>
<p>Destructor must destroy ALL memory that was allocated using their corresponding destructors</p>
<p>DESIGN: Relevant to the pipeline, the memory lender does not provide extra functionality to ensure a clean system shutdown. It is assumed that every thread written can be terminated with malice and will not affect the data output. Specifically, it is assumed that MS files will be written per time integration and that any final grids will be lost if they are in the course of accumulation.</p>
<p>NOTE: If system is shut down during operation, the memory waiting in the queue or used by other threads is NOT freed. Unless the implementation is changed to allocate memory that cannot be cleaned by OS after the process, this should be fine. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5805700698114c984d659c8d4f4333e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5805700698114c984d659c8d4f4333e2">&#9670;&nbsp;</a></span>return_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrecycle__memory.html">recycle_memory</a>&lt; T &gt;::return_memory </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function to reclaim memory </p>
<p>Is given to all created buffer_ptrs so raw pointers boomerang back to the correct lending object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer (of the <a class="el" href="classbuffer__ptr.html" title="smart wrapper for shared_ptr">buffer_ptr</a> that is being destroyed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9312bd45680bd8fbfd766b5f271c081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9312bd45680bd8fbfd766b5f271c081">&#9670;&nbsp;</a></span>shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrecycle__memory.html">recycle_memory</a>&lt; T &gt;::shape</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: Idk what this is for lol. </p>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;size_t&gt;&amp; </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="lender_8hpp_source.html">lender.hpp</a></li>
<li><a class="el" href="recycler_8hpp_source.html">recycler.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
